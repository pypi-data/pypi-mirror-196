"""Pipleline"""

import typing as T
import shutil
import tempfile
import zipfile
from enum import Enum, auto
import json
from pathlib import Path

#  from datetime import datetime

import validators
from bitia import version
import bitia.config as bconfig
from bitia.common import sha256sum, dir_info
from bitia.logger import logger
from bitia.checksumdir import dirhash


class UserInputType(Enum):
    """Type of user input"""

    STR_COMMAND = auto()
    FILE_SCRIPT = auto()
    FILE_ZIP = auto()
    DIR_SCRIPT = auto()
    UNKNOWN = auto()


class Pipeline:
    def __init__(self, zipfile: Path, user_input=None, **kwargs):
        self.zipfile: Path = zipfile
        self.hash: str = sha256sum(zipfile)
        self.user_input = user_input
        self.type: UserInputType = UserInputType.UNKNOWN

    def __eq__(self, other):
        return self.checksum == other.checksum and self.size == other.size

    def __repr__(self) -> str:
        return json.dumps(
            dict(file=str(self.zipfile), checksum=self.checksum, size=self.size),
            sort_keys=True,
            indent=2,
        )

    def is_a_command(self) -> bool:
        return self.type == UserInputType.STR_COMMAND

    @property
    def size(self) -> int:
        return self.zipfile.stat().st_size

    @property
    def checksum(self) -> str:
        return self.hash

    def data(self) -> T.Dict[str, T.Any]:
        """Return the pipeline key properties. This is often sent to the
        server."""
        return dict(
            zip_filename=self.zipfile.name, checksum=self.checksum, size=self.size
        )

    @classmethod
    def from_command(cls, cmd: str, *, comment: str = "") -> "Pipeline":
        """Create a pipeline from user command. The semantics is a bit different
        for this.
        """
        pipeline_dir = Path(tempfile.mkdtemp(prefix="bitia_"))
        pipeline_file = pipeline_dir / bconfig.BITIA_MAIN_SCRIPT_NAME
        lines: T.List[str] = []
        lines.append("#!/bin/sh")
        lines.append(f"# generated by bitia-cli version: {version()}")
        lines.append("# (c) 2022-, Subconscious Compute")
        assert "\n" not in comment, "An eol char is found in comment"
        lines.append(f"# {comment}")
        lines.append(f"{cmd}")
        pipeline_file.write_text("\n".join(lines))
        logger.debug("Wrote pipeline %s", pipeline_file.read_text())
        pipeline = Pipeline.from_directory(pipeline_dir)
        pipeline.user_input = cmd
        return pipeline

    @classmethod
    def from_script(cls, script: Path) -> "Pipeline":
        """Create a pipelinefile from a single script"""
        assert script.is_file(), f"{script} is not a file"
        pipeline_dir = Path(tempfile.mkdtemp(prefix="bitia_"))
        pipeline_file = pipeline_dir / bconfig.BITIA_MAIN_SCRIPT_NAME
        # move the script to this directory.
        shutil.copy2(script, pipeline_dir)
        script_name = script.name
        with pipeline_file.open("w", newline="\n") as outf:
            outf.write(f"#!/bin/sh\nchmod +x ./{script_name}\n./{script_name}")
        pipeline = Pipeline.from_directory(pipeline_dir)
        pipeline.user_input = script
        return pipeline

    @classmethod
    def from_directory(cls, user_dir: Path) -> "Pipeline":
        """Create pipeline from a directory"""
        dinfo = dir_info(user_dir)
        content_hash = dirhash(user_dir)
        outfile = bconfig.bitia_dir() / "pipelines" / f"{content_hash}.zip"
        if not outfile.is_file():
            logger.info(f"Preparing the zipfile pipeline from {user_dir}")
            logger.info(
                f" size={dinfo['size_in_mb']} MB, total files={dinfo['num_files']}"
            )
            outfile.parent.mkdir(parents=True, exist_ok=True)
            assert dinfo["files"], f"No file found in {user_dir}"
            with zipfile.ZipFile(outfile, "w", zipfile.ZIP_DEFLATED) as zfile:
                for entry in dinfo["files"]:
                    logger.info(f"Adding {entry} to zipfile")
                    zfile.write(entry)

            # check the prepared zip file.
            with zipfile.ZipFile(outfile) as zfile:
                assert zfile.namelist(), "Empty zipfile"
        else:
            logger.info(f"Reusing the existing pipeline `{outfile}`.")

        # assert non-zero size of the zip file.
        assert outfile.is_file(), f"{outfile} does not exists"
        return cls(outfile)


def user_input_to_pipeline(user_input: str) -> Pipeline:
    """Create a pipeline file from user_input"""
    if (path := Path(user_input)).exists():
        if path.is_dir():
            pipeline = Pipeline.from_directory(path)
            pipeline.type = UserInputType.DIR_SCRIPT
            return pipeline
        if path.is_file() and path.suffix.lower() == ".zip":
            pipeline = Pipeline(path, str(path.resolve()))
            pipeline.type = UserInputType.FILE_ZIP
            return pipeline
        pipeline = Pipeline.from_script(path)
        pipeline.type = UserInputType.FILE_SCRIPT
        return pipeline
    if validators.url(user_input):
        raise NotImplementedError("Fetching pipeline from url is not supported")
    pipeline = Pipeline.from_command(user_input)
    pipeline.type = UserInputType.STR_COMMAND
    return pipeline
